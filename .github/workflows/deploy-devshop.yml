name: Build and Deploy devShop

on:
  workflow_dispatch:
  push:
    branches: [ main ]
    paths:
      - 'src/devShop/**'
      - '.github/workflows/deploy-devshop.yml'
      
env:
  AZURE_RESOURCE_GROUP: rg-devShop
  WEB_VM_NAME: vm-web-devShop
  DOTNET_VERSION: '4.8'

jobs:
  build-and-deploy:
    runs-on: windows-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@v1.1
    
    - name: Setup NuGet
      uses: NuGet/setup-nuget@v1
    
    - name: Restore NuGet packages
      run: nuget restore src/devShop.sln
    
    - name: Build solution
      run: msbuild src/devShop.sln /p:Configuration=Release /p:Platform="Any CPU" /p:DeployOnBuild=false
    
    - name: Verify build output
      shell: pwsh
      run: |
        Write-Host "Checking build output:"
        if (Test-Path "src/devShop/bin/Release") {
          Write-Host "‚úì bin/Release folder exists"
          Get-ChildItem "src/devShop/bin/Release" | Select-Object Name, Length
        } else {
          Write-Host "‚úó bin/Release folder NOT found"
          Write-Host "Searching for bin folder:"
          Get-ChildItem "src/devShop" -Directory -Recurse -Filter "bin" | Select-Object FullName
        }
    
    - name: Prepare deployment package
      shell: pwsh
      run: |
        $publishDir = "publish"
        New-Item -ItemType Directory -Path $publishDir -Force
        
        # Copy all application files from src/devShop INCLUDING bin folder this time
        Write-Host "Copying application files with bin folder..."
        Copy-Item -Path "src/devShop/*" -Destination $publishDir -Recurse -Exclude @('obj', '*.csproj.user', 'packages')
        
        Write-Host "`nVerifying bin folder in publish directory:"
        if (Test-Path "$publishDir/bin") {
          Write-Host "‚úì bin folder exists"
          Get-ChildItem "$publishDir/bin" -File | Select-Object Name, Length | Format-Table
        } else {
          throw "ERROR: bin folder not copied!"
        }
        
        Write-Host "`nChecking for devShop.dll:"
        $dll = Get-ChildItem "$publishDir/bin" -Filter "devShop.dll" -ErrorAction SilentlyContinue
        if ($dll) {
          Write-Host "‚úì devShop.dll found: $($dll.Length) bytes"
        } else {
          Write-Host "‚úó devShop.dll NOT found!"
          Write-Host "All DLLs in bin:"
          Get-ChildItem "$publishDir/bin" -Filter "*.dll" | Select-Object Name
        }
    
    - name: Create deployment package
      shell: pwsh
      run: |
        Compress-Archive -Path "publish\*" -DestinationPath "built-app.zip" -Force
        Write-Host "Package created: $(Get-Item built-app.zip | Select-Object Name, Length)"        
        # Verify ZIP contents
        Write-Host "`nVerifying ZIP contents:"
        Add-Type -AssemblyName System.IO.Compression.FileSystem
        $zip = [System.IO.Compression.ZipFile]::OpenRead("built-app.zip")
        $binFiles = $zip.Entries | Where-Object { $_.FullName -like "bin/*" }
        Write-Host "Files in bin folder within ZIP:"
        $binFiles | Select-Object FullName, Length | Format-Table
        $zip.Dispose()
        
        if ($binFiles.Count -eq 0) {
          throw "ERROR: bin folder not in ZIP file!"
        }
        Write-Host "‚úì ZIP file contains $($binFiles.Count) files in bin folder"    
    - name: Azure Login
      shell: pwsh
      run: |
        $creds = '${{ secrets.AZURE_CREDENTIALS }}' | ConvertFrom-Json
        az login --service-principal `
          --username $creds.clientId `
          --password $creds.clientSecret `
          --tenant $creds.tenantId
        az account set --subscription $creds.subscriptionId
        
        # Save credentials to environment for later steps
        "AZURE_CLIENT_ID=$($creds.clientId)" >> $env:GITHUB_ENV
        "AZURE_RESOURCE_GROUP=${{ secrets.RESOURCE_GROUP }}" >> $env:GITHUB_ENV
    
    - name: Upload package to VM and deploy
      shell: pwsh
      run: |
        Write-Host "Deploying built application package to VM..."
        
        # Parse credentials and set variables
        $creds = '${{ secrets.AZURE_CREDENTIALS }}' | ConvertFrom-Json
        $clientId = $creds.clientId
        $resourceGroup = 'rg-devShop'
        $vmName = 'vm-web-devShop'
        
        Write-Host "Resource Group: $resourceGroup"
        Write-Host "VM Name: $vmName"
        Write-Host "Client ID: $clientId"
        
        Write-Host "Creating deployment package from built files..."
        Compress-Archive -Path "publish\*" -DestinationPath "built-app.zip" -Force
        $zipSize = (Get-Item "built-app.zip").Length / 1MB
        Write-Host "Package size: $([math]::Round($zipSize, 2)) MB"
        
        # Create a temporary storage account for deployment
        $timestamp = Get-Date -Format "yyyyMMddHHmmss"
        $storageAccountName = "devshoptmp$timestamp".ToLower().Substring(0, 24)
        $containerName = "deploy"
        
        Write-Host "Creating temporary storage account: $storageAccountName"
        az storage account create `
          --name $storageAccountName `
          --resource-group $resourceGroup `
          --location westeurope `
          --sku Standard_LRS `
          --allow-blob-public-access true
        
        # Wait for account to be ready and role to propagate
        Write-Host "Waiting for storage account and permissions to be ready..."
        Start-Sleep -Seconds 30
        
        Write-Host "Creating container with public access..."
        $retryCount = 0
        $maxRetries = 3
        $containerCreated = $false
        
        while (-not $containerCreated -and $retryCount -lt $maxRetries) {
          $retryCount++
          Write-Host "Attempt $retryCount to create container..."
          
          az storage container create `
            --name $containerName `
            --account-name $storageAccountName `
            --public-access blob `
            --auth-mode login
          
          # Verify container exists
          Start-Sleep -Seconds 5
          $exists = az storage container exists `
            --name $containerName `
            --account-name $storageAccountName `
            --auth-mode login `
            --query exists -o tsv
          
          if ($exists -eq 'true') {
            $containerCreated = $true
            Write-Host "Container verified as existing"
          } else {
            Write-Host "Container not found, waiting before retry..."
            Start-Sleep -Seconds 10
          }
        }
        
        if (-not $containerCreated) {
          throw "Failed to create container after $maxRetries attempts"
        }
        
        Write-Host "Container created successfully"
        
        Write-Host "Uploading package..."
        az storage blob upload `
          --account-name $storageAccountName `
          --container-name $containerName `
          --name "built-app.zip" `
          --file "built-app.zip" `
          --auth-mode login `
          --overwrite
        
        $blobUrl = "https://$storageAccountName.blob.core.windows.net/$containerName/built-app.zip"
        Write-Host "Package uploaded to: $blobUrl"
        
        # Create deployment script that downloads from blob
        $scriptContent = @'
        $ErrorActionPreference = 'Stop'
        Write-Host 'Deploying built application with compiled DLLs...'
        
        $appPath = 'C:\inetpub\wwwroot\devShop'
        $zipPath = 'C:\Temp\built-app.zip'
        '@
        
        $scriptContent += "`n`$blobUrl = '$blobUrl'"
        
        $scriptContent += @'
        
        Write-Host 'Downloading package from storage...'
        New-Item -ItemType Directory -Path 'C:\Temp' -Force | Out-Null
        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
        Invoke-WebRequest -Uri $blobUrl -OutFile $zipPath -UseBasicParsing
        
        Write-Host 'Stopping IIS...'
        Import-Module WebAdministration
        Stop-WebAppPool -Name 'devShopPool' -ErrorAction SilentlyContinue
        Start-Sleep -Seconds 2
        
        Write-Host 'Clearing existing files...'
        if (Test-Path $appPath) {
          Remove-Item "$appPath\*" -Recurse -Force -ErrorAction SilentlyContinue
        } else {
          New-Item -ItemType Directory -Path $appPath -Force | Out-Null
        }
        
        Write-Host 'Extracting application...'
        Expand-Archive -Path $zipPath -DestinationPath $appPath -Force
        
        Write-Host 'Checking what was extracted...'
        Write-Host "Total files extracted: $((Get-ChildItem $appPath -Recurse -File).Count)"
        Write-Host "Directories:"
        Get-ChildItem $appPath -Directory | Select-Object Name
        
        Write-Host 'Setting permissions...'
        icacls $appPath /grant 'IIS_IUSRS:(OI)(CI)RX' /T | Out-Null
        icacls $appPath /grant 'IUSR:(OI)(CI)RX' /T | Out-Null
        if (Test-Path "$appPath\App_Data") {
          icacls "$appPath\App_Data" /grant 'IIS_IUSRS:(OI)(CI)F' /T | Out-Null
        }
        
        Write-Host 'Starting IIS...'
        Start-WebAppPool -Name 'devShopPool'
        Start-Website -Name 'devShop' -ErrorAction SilentlyContinue
        
        Write-Host 'Deployment complete!'
        Write-Host 'Verifying bin folder:'
        Get-ChildItem "$appPath\bin" -ErrorAction SilentlyContinue | Select-Object Name, Length | ForEach-Object { Write-Host "  $($_.Name) - $($_.Length) bytes" }
        
        Remove-Item $zipPath -Force -ErrorAction SilentlyContinue
        '@
        
        Write-Host "Executing deployment on VM..."
        az vm run-command invoke `
          --resource-group $resourceGroup `
          --name $vmName `
          --command-id RunPowerShellScript `
          --scripts $scriptContent
        
        Write-Host "Cleaning up temporary storage account..."
        az storage account delete `
          --name $storageAccountName `
          --resource-group $resourceGroup `
          --yes
    
    - name: Verify deployment
      shell: pwsh
      run: |
        $webUrl = az vm show -d --resource-group $env:AZURE_RESOURCE_GROUP --name $env:WEB_VM_NAME --query "publicIps" -o tsv
        $url = "http://$webUrl"
        
        Write-Host "Waiting for application to start..."
        Start-Sleep -Seconds 5
        
        try {
          $response = Invoke-WebRequest -Uri $url -UseBasicParsing -TimeoutSec 10
          Write-Host "‚úÖ Deployment successful! Status: $($response.StatusCode)"
          Write-Host "üåê Application URL: $url"
        } catch {
          Write-Host "‚ö†Ô∏è Application deployed but may need time to start: $_"
          Write-Host "üåê Check manually: $url"
        }
